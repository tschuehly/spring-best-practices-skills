# Processing Highlights

Noteworthy events during blog article processing — good anecdotes for the blog post.

- **#1**: First blog article processed! "Consider using JSON arrays instead of JSON objects for serialisation" (2025-08-11) — enriched existing doc-seeded `multiset.md` with internal serialization performance details (~80% speedup with arrays vs objects for 10k rows).
- **#2**: New topic file created: `array-operations.md` — "When SQL Meets Lambda Expressions" (2025-03-27). jOOQ brings functional array operations (arrayFilter, arrayMap, etc.) to SQL, with PostgreSQL emulation via unnest/reaggregate.
- **#3**: New topic file created: `merge-upsert.md` — "Think About SQL MERGE in Terms of a RIGHT JOIN" (2025-03-13). First pure SQL pattern (no jOOQ-specific API). Mental model: MERGE = RIGHT JOIN, with PostgreSQL 17's `NOT MATCHED BY SOURCE` turning it into a FULL JOIN for complete staging table sync.
- **#8**: Doc-seeded entry enriched: "An Efficient Way to Check for Existence of Multiple Values in SQL" (2024-02-16) extends the existing EXISTS vs COUNT(*) anti-pattern. When you *do* need COUNT >= N, wrapping in LIMIT N gives ~2.5x speedup on PostgreSQL by stopping early.
- **#9**: New topic file created: `implicit-joins.md` — "A Hidden Benefit of Implicit Joins: Join Elimination" (2024-01-10). jOOQ 3.19 introduced automatic join elimination for implicit path joins — intermediate tables with no referenced columns are removed from the generated SQL. First version-gated feature (Since: 3.19) in the knowledge base.
- **#10**: Older article enriched newer topic: "jOOQ 3.19's new Explicit and Implicit to-many path joins" (2023-12-28) added 3 patterns to `implicit-joins.md` that the newer #9 article didn't cover — explicit path joins (control join type), implicit join path correlation (auto-correlated subqueries), and MULTISET+path combos. Also enriched the to-many section with the cartesian product warning. First "Supersedes" note added to the knowledge base.
- **#14**: Doc-seeded entry enriched: "To DAO or not to DAO" (2023-12-06) expanded the bare "Avoid N+1 queries" anti-pattern with concrete DAO criticism — jOOQ's DAO API makes it easy to hide N+1 loops inside `findByX()` methods. Added bulk SQL alternative using UPDATE+EXISTS.
- **#16**: New topic file created: `code-generator.md` — "How to Generate Package Private Code with jOOQ's Code Generator" (2023-06-28). First code generator configuration topic — covers visibility modifiers and custom generator strategies to hide generated code from client packages.
- **#18**: New topic file created: `hierarchical-queries.md` — "How to Turn a List of Flat Elements into a Hierarchy in Java, SQL, or jOOQ" (2023-03-24). Introduces `Records.intoHierarchy()` collector (since 3.19) — turns flat parent-child rows into a tree with a single `.collect()` call. Also covers the recursive CTE alternative for SQL-side hierarchy building.
- **#21**: New topic file created: `derived-tables.md` — "How to Write a Derived Table in jOOQ" (2023-02-24). Key insight: most derived tables are unnecessary — flattening restores full generated-code type safety. When you do need them, extract `Field<T>` references and use `nested.field(fieldRef)` for safer column access.
- **#22**: New topic file created: `aggregate-functions.md` — "The Performance Impact of SQL's FILTER Clause" (2023-02-06). First pure SQL performance benchmark in the knowledge base. FILTER syntax is ~8% faster than equivalent CASE on PostgreSQL 15, plus jOOQ auto-emulates FILTER as CASE for unsupported databases. Added FILTER preference as a new core rule.
- **#20**: Doc-seeded entry enriched: "How to use jOOQ's Converters with UNION Operations" (2023-03-02) adds a critical pitfall to the existing ad-hoc converter pattern in `fetching-mapping.md`. Converters are client-side post-fetch — in UNION queries, only the first subquery's row type is used, so converters on other subqueries silently do nothing. Fix: use server-side functions (e.g., `.neg()`) instead.
- **#24**: New core rule added: "Why You Should Execute jOOQ Queries With jOOQ" (2023-01-18) — the definitive anti-pattern: don't build queries with jOOQ DSL only to extract SQL for JDBC/JPA. You lose MULTISET emulation, type-safe mapping, stored procedure wrappers, dialect-portable identity fetching, and R2DBC support. Merged into `anti-patterns.md` and added as a core rule in SKILL.md.
- **#25**: New topic file created: `logging.md` — "jOOQ's R2DBC LoggingConnection to log all SQL statements" (2023-01-17). R2DBC equivalent of JDBC's LoggingConnection — wraps reactive connections to log all SQL at DEBUG level. Available since jOOQ 3.18.
- **#26**: New topic file created: `native-sql-strategy.md` — "When to Use jOOQ and When to Use Native SQL" (2022-12-08). Pragmatic hybrid approach: extract complex static SQL into database views or table-valued functions, then let jOOQ code-gen them for full type safety. Complements the #24 anti-pattern — you don't need to abandon jOOQ for complex queries, just push the complexity into the schema.
- **#29**: Version evolution highlight: "Using jOOQ's Implicit Join From Within the JOIN .. ON Clause" (2022-09-13) shows implicit joins existed since jOOQ 3.11 — the earlier entries in `implicit-joins.md` cover 3.19 enhancements. This older article adds a distinct pattern: using implicit path expressions (`pgA.pgClass().RELNAME`) within an explicit JOIN's ON clause, causing jOOQ to nest joins to preserve SQL operator precedence. Also introduces synthetic foreign keys for `pg_catalog` views — a code generator config that enables implicit joins on schemas without real FKs.
- **#30**: New topic file created: `type-system.md` — "A Brief Overview over the Most Common jOOQ Types" (2022-09-06). A type hierarchy cheat sheet with 6 actionable patterns: never reference Step types in user code, DSLContext vs static DSL for execution vs expression building, Result vs Cursor for memory management, Converter vs Binding for custom types (prefer Converter), Select's four roles (top-level/subquery/derived table/union), and Row value expressions for tuple comparisons.
- **#34**: Version evolution highlight: "jOOQ 3.17 Supports Implicit Join also in DML" (2022-08-25) extends implicit joins from SELECT-only to UPDATE/DELETE. jOOQ emulates via correlated subqueries (universal) or DML JOIN syntax (MySQL/MariaDB). Shows incremental growth of implicit join support: 3.11 (SELECT), 3.17 (DML), 3.19 (to-many + path correlation).
- **#28**: New topic file created: `stored-procedures.md` — "Calling Procedures with Default Parameters using JDBC or jOOQ" (2022-10-21). Key pattern: instantiate the generated procedure class directly (skip `Routines` shortcut) to omit defaulted params. jOOQ renders anonymous blocks with named parameter syntax (`"P_I1" => ?`) instead of JDBC escape syntax. Works across 5 dialects: Db2, Informix, Oracle, PostgreSQL, SQL Server.
